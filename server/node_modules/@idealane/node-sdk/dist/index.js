"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdealaneDB = exports.IdealaneSDK = void 0;
const pg_1 = require("pg");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
class IdealaneSDK {
    constructor(config) {
        if (!config) {
            // Allow empty instantiation if only using DB separately, or fail later
            this.jwtSecret = '';
            this.db = new IdealaneDB('');
            return;
        }
        this.jwtSecret = config.jwtSecret;
        this.db = new IdealaneDB(config.dbConfig);
    }
    // Middleware to validate session and set context
    authMiddleware() {
        return (req, res, next) => {
            const authHeader = req.headers.authorization;
            if (!authHeader) {
                return res.status(401).json({ error: 'No token provided' });
            }
            const token = authHeader.split(' ')[1];
            try {
                const decoded = jsonwebtoken_1.default.verify(token, this.jwtSecret);
                // Set context for the request
                req.user = decoded;
                req.projectID = decoded.pid; // Project ID from token claim
                // IMPORTANT: Pass project context to DB connection handling
                // This assumes we might use a scoped DB accessor later
                next();
            }
            catch (err) {
                return res.status(401).json({ error: 'Invalid token' });
            }
        };
    }
}
exports.IdealaneSDK = IdealaneSDK;
class IdealaneDB {
    constructor(configOrUrl) {
        // Read schema from environment if available
        this.schema = process.env.DB_SCHEMA || 'public';
        if (typeof configOrUrl === 'string') {
            this.pool = new pg_1.Pool({
                connectionString: configOrUrl,
                ssl: { rejectUnauthorized: false }
            });
        }
        else {
            const config = {
                ...configOrUrl,
                ssl: { rejectUnauthorized: false }
            };
            this.pool = new pg_1.Pool(config);
        }
    }
    // Query method with automatic schema isolation
    async query(text, params) {
        const client = await this.pool.connect();
        try {
            // Set search_path to project schema before each query
            await client.query(`SET search_path TO "${this.schema}", public`);
            return await client.query(text, params);
        }
        finally {
            client.release();
        }
    }
}
exports.IdealaneDB = IdealaneDB;
