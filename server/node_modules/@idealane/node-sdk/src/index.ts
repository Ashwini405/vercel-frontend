import { Request, Response, NextFunction } from 'express';
import { Pool, PoolClient, PoolConfig } from 'pg';
import jwt from 'jsonwebtoken';

interface MiddlewareConfig {
    jwtSecret: string;
}

interface DBConfig extends PoolConfig {
    // Standard pg config
}

export class IdealaneSDK {
    private jwtSecret: string;
    public db: IdealaneDB;

    constructor(config?: { jwtSecret: string, dbConfig: DBConfig }) {
        if (!config) {
            // Allow empty instantiation if only using DB separately, or fail later
            this.jwtSecret = '';
            this.db = new IdealaneDB('');
            return;
        }
        this.jwtSecret = config.jwtSecret;
        this.db = new IdealaneDB(config.dbConfig);
    }

    // Middleware to validate session and set context
    public authMiddleware() {
        return (req: Request, res: Response, next: NextFunction) => {
            const authHeader = req.headers.authorization;
            if (!authHeader) {
                return res.status(401).json({ error: 'No token provided' });
            }

            const token = authHeader.split(' ')[1];
            try {
                const decoded = jwt.verify(token, this.jwtSecret) as any;

                // Set context for the request
                (req as any).user = decoded;
                (req as any).projectID = decoded.pid; // Project ID from token claim

                // IMPORTANT: Pass project context to DB connection handling
                // This assumes we might use a scoped DB accessor later
                next();
            } catch (err) {
                return res.status(401).json({ error: 'Invalid token' });
            }
        };
    }
}

export class IdealaneDB {
    private pool: Pool;
    private schema: string;

    constructor(configOrUrl: DBConfig | string) {
        // Read schema from environment if available
        this.schema = process.env.DB_SCHEMA || 'public';

        if (typeof configOrUrl === 'string') {
            this.pool = new Pool({
                connectionString: configOrUrl,
                ssl: { rejectUnauthorized: false }
            });
        } else {
            const config = {
                ...configOrUrl,
                ssl: { rejectUnauthorized: false }
            };
            this.pool = new Pool(config);
        }
    }

    // Query method with automatic schema isolation
    public async query(text: string, params?: any[]): Promise<any> {
        const client = await this.pool.connect();
        try {
            // Set search_path to project schema before each query
            await client.query(`SET search_path TO "${this.schema}", public`);
            return await client.query(text, params);
        } finally {
            client.release();
        }
    }
}
